{% extends "Base.html" %}
{% load static %}
{% block title %}
  <title>Short Circuit Analysis</title>
{% endblock %}
{% block content %}
<h1>Line Co-ordination</h1>
<p>Short Circuit Analysis</p>
<style>
  body {
    margin: 0;
    padding: 0;
  }
  .container {
    display: flex;
    flex-wrap: nowrap;
    width: 100%;
    box-sizing: border-box;
  }
  #sidebar {
    font-size: 10px;
    width: 100px;
    flex-shrink: 0;
    background-color: #f4f4f4;
    padding: 5px;
    box-sizing: border-box;
    margin-left: -20px;
  }
  #sidebar h4 {
    font-size: 16px;
  }
  #content {
    font-size: 10px;
    flex: 1;
    padding: 3px;
    box-sizing: border-box;
  }
  #c {
    width: 1680px;
    height: 720px;
    border: 1px solid #ccc;
  }
  .menu-item {
    font-size: 10px;
    background-color: #ffffff;
    margin: 3px;
    padding: 3px;
    text-align: center;
    cursor: pointer;
  }
  @media (max-width: 768px) {
    .container {
      flex-direction: column;
    }
    #sidebar {
      width: 100%;
    }
  }
</style>

<div class="container">
  <div id="sidebar">
    <h4>เมนูอุปกรณ์</h4>
    <!-- เมื่อคลิกแต่ละเมนูจะเรียก selectDevice() -->
    <div class="menu-item" onclick="selectDevice('ExternalGrid')">External Grid</div>
    <div class="menu-item" onclick="selectDevice('Recloser')">Recloser</div>
    <div class="menu-item" onclick="selectDevice('Fuse')">Fuse</div>
    <div class="menu-item" onclick="selectDevice('Line')">Line</div>
    <div class="menu-item" onclick="selectDevice('Node')">Node</div>
    <hr>
    <div class="menu-item" onclick="clearCanvas()">Clear Canvas</div>
  </div>
  <div id="content">
    <canvas id="c"></canvas>
  </div>
</div>

{% include "Title_Box.html" %}

<script>
// Global Variables
window.selectedNodes = [];
window.allNodes = [];
window.connectedDevices = [];
window.selectedDeviceType = null;
window.previewObject = null;
window.pendingManualConnectionDevice = null;
window.manualPreviewLine = null;
window.lineStartNode = null;
window.devicePendingPreviewLine = null;
window.manualLinePreview = null;
window.loadedSVG = {};

// Constants
const gridSize = 50, connectionThreshold = 0;

// Inline SVG Strings
const inlineExternalGridSVG = `
<svg width="200" height="200" viewBox="0 0 200 200"
     xmlns="http://www.w3.org/2000/svg">
  <rect x="0" y="0" width="200" height="200" fill="none" stroke="black" stroke-width="2"/>
  <line x1="0" y1="0" x2="200" y2="200" stroke="black" stroke-width="2"/>
  <line x1="200" y1="0" x2="0" y2="200" stroke="black" stroke-width="2"/>
  <line x1="100" y1="0" x2="100" y2="200" stroke="black" stroke-width="2"/>
  <line x1="0" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
</svg>
`;
const inlineRecloserSVG = `
<svg width="100" height="100" viewBox="0 0 100 100"
     xmlns="http://www.w3.org/2000/svg">
  <rect x="5" y="5" width="90" height="90" fill="none" stroke="black" stroke-width="2"/>
  <text x="50" y="60" font-size="40" text-anchor="middle" fill="black" dy="0.35em">R</text>
</svg>
`;
const inlineFuseSVG = `
<svg version="1.1" width="120" height="40" viewBox="0 0 120 40"
     xmlns="http://www.w3.org/2000/svg">
  <line x1="0" y1="20" x2="20" y2="20" stroke="black" stroke-width="3"/>
  <rect x="20" y="5" width="80" height="30" fill="none" stroke="black" stroke-width="3"/>
  <line x1="20" y1="20" x2="100" y2="20" stroke="black" stroke-width="3"/>
  <line x1="100" y1="20" x2="120" y2="20" stroke="black" stroke-width="3"/>
</svg>
`;

// Helper Functions
function snapPointToGrid(x, y) {
  const offset = gridSize / 2;
  return {
    x: offset + Math.round((x - offset) / gridSize) * gridSize,
    y: offset + Math.round((y - offset) / gridSize) * gridSize
  };
}

function distance(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

function updateDeviceRotation(device) {
  if (device.connectionNodes.length !== 2) return;
  let [node1, node2] = device.connectionNodes;
  let center1 = node1.getCenterPoint();
  let center2 = node2.getCenterPoint();
  if (center2.x < center1.x) {
    [node1, node2] = [node2, node1];
    center1 = node1.getCenterPoint();
    center2 = node2.getCenterPoint();
  }
  let angle = Math.atan2(center2.y - center1.y, center2.x - center1.x) * 180 / Math.PI;
  device.set('angle', angle);
  device.setCoords();
  canvas.renderAll();
  console.log("Device rotated to angle:", angle);
}

// Update Z-Order: กำหนดลำดับการวาดโดยใช้ sort() กับ canvas._objects
function updateZOrder() {
  // กำหนด order ให้กับแต่ละประเภท (order ต่ำ = วาดก่อน = อยู่ด้านหลัง)
  function getOrder(obj) {
    if (obj.type === 'line') {
      return 0; // เส้นอยู่ด้านล่างสุด
    } else if (obj.type === 'circle') {
      return 1; // Node อยู่กลาง
    } else if (obj.type === 'group') {
      return 2; // Device อยู่บนสุด
    }
    return 1; // ค่าเริ่มต้น
  }

  canvas._objects = canvas._objects.sort(function(a, b) {
    return getOrder(a) - getOrder(b);
  });
  canvas.renderAll();
}

function showManualPreviewLine(device) {
  const deviceCenter = device.getCenterPoint();
  const previewEnd = { x: deviceCenter.x, y: deviceCenter.y };
  if (window.devicePendingPreviewLine) {
    canvas.remove(window.devicePendingPreviewLine);
    window.devicePendingPreviewLine = null;
  }
  window.devicePendingPreviewLine = new fabric.Line(
    [deviceCenter.x, deviceCenter.y, previewEnd.x, previewEnd.y],
    { stroke: 'red', strokeWidth: 4, selectable: false, evented: false, opacity: 0.5 }
  );
  canvas.add(window.devicePendingPreviewLine);
  canvas.renderAll();
  console.log("Manual preview line shown.");
}

function removeDeviceConnections(device) {
  if (device.connectionLines && device.connectionLines.length > 0) {
    device.connectionLines.forEach(line => canvas.remove(line));
    device.connectionLines = [];
    device.connectionNodes = [];
  }
}

function removeNodeConnections(node) {
  if (!node.connectedDevices || !Array.isArray(node.connectedDevices)) return;
  node.connectedDevices.forEach(function(device) {
    const idx = device.connectionNodes.indexOf(node);
    if (idx > -1) {
      if (device.manualOnly === true) {
        canvas.remove(device);
      } else {
        canvas.remove(device.connectionLines[idx]);
        device.connectionLines.splice(idx, 1);
        device.connectionNodes.splice(idx, 1);
      }
    }
  });
  canvas.getObjects().forEach(function(obj) {
    if (obj.type === 'line' && (obj.myStartNode === node || obj.myEndNode === node)) {
      canvas.remove(obj);
    }
  });
}

// Document Ready
document.addEventListener('DOMContentLoaded', function() {
  canvas = new fabric.Canvas('c', { selection: false });

  // Prevent deselection default behavior
  canvas.on('before:selection:cleared', function(opt) {
    if (opt.e) opt.e.preventDefault();
  });
  canvas.on('object:removed', function(e) {
    let obj = e.target;
    if (obj.type === 'circle') removeNodeConnections(obj);
    if (obj.type === 'group') removeDeviceConnections(obj);
  });

  // Context menu cancels preview and connection
  canvas.upperCanvasEl.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    if (window.previewObject) {
      canvas.remove(window.previewObject);
      window.previewObject = null;
    }
    window.selectedDeviceType = null;
    if (window.devicePendingPreviewLine) {
      canvas.remove(window.devicePendingPreviewLine);
      window.devicePendingPreviewLine = null;
    }
    if (window.manualLinePreview) {
      canvas.remove(window.manualLinePreview);
      window.manualLinePreview = null;
    }
    window.pendingManualConnectionDevice = null;
    window.lineStartNode = null;
    console.log("Preview and pending connection cancelled.");
  });

  canvas.isDragging = false;
  canvas.lastPosX = 0;
  canvas.lastPosY = 0;

  // updatePreview สร้าง preview ตาม pointer และ selectedDeviceType
  function updatePreview(pointer) {
    if (!window.selectedDeviceType) return;

    if (window.previewObject) {
      window.previewObject.set({ left: pointer.x, top: pointer.y });
      canvas.renderAll();
      return;
    }

    if (window.selectedDeviceType === 'Node') {
      window.previewObject = new fabric.Circle({
        left: pointer.x,
        top: pointer.y,
        radius: 5,
        fill: 'black',
        selectable: false,
        evented: false,
        opacity: 0.5,
        originX: 'center',
        originY: 'center'
      });
      canvas.add(window.previewObject);
      canvas.renderAll();
    } else if (window.selectedDeviceType === 'Line') {
      window.previewObject = new fabric.Text("line", {
        left: pointer.x,
        top: pointer.y,
        fontSize: 16,
        fill: 'black',
        selectable: true,
        evented: true,
        originX: 'center',
        originY: 'center',
        opacity: 0.8
      });
      window.previewObject.deviceType = "Line";
      console.log("Created Line preview with deviceType:", window.previewObject.deviceType);
      canvas.add(window.previewObject);
      canvas.renderAll();
      updateZOrder();
    } else if (window.selectedDeviceType === 'ExternalGrid') {
      // สำหรับ ExternalGrid ใช้ inline SVG ที่ประกาศไว้
      fabric.loadSVGFromString(inlineExternalGridSVG, function(objects, options) {
        if (!objects || objects.length === 0) return;
        let preview = new fabric.Group(objects, options);
        preview.scaleToWidth(40);
        preview.set({
          left: pointer.x,
          top: pointer.y,
          opacity: 0.5,
          selectable: false,
          evented: false,
          originX: 'center',
          originY: 'center',
          deviceType: 'ExternalGrid'
        });
        window.previewObject = preview;
        canvas.add(preview);
        canvas.renderAll();
        updateZOrder();
      });
      return;
    } else if (window.selectedDeviceType === 'Recloser') {
      fabric.loadSVGFromString(inlineRecloserSVG, function(objects, options) {
        if (!objects || objects.length === 0) return;
        let preview = new fabric.Group(objects, options);
        preview.scaleToWidth(40);
        preview.set({
          left: pointer.x,
          top: pointer.y,
          opacity: 0.5,
          selectable: false,
          evented: false,
          originX: 'center',
          originY: 'center',
          deviceType: 'Recloser'
        });
        window.previewObject = preview;
        canvas.add(preview);
        canvas.renderAll();
        updateZOrder();
      });
      return;
    } else if (window.selectedDeviceType === 'Fuse') {
      fabric.loadSVGFromString(inlineFuseSVG, function(objects, options) {
        if (!objects || objects.length === 0) return;
        let preview = new fabric.Group(objects, options);
        preview.scaleToWidth(40);
        preview.set({
          left: pointer.x,
          top: pointer.y,
          opacity: 0.5,
          selectable: false,
          evented: false,
          originX: 'center',
          originY: 'center',
          deviceType: 'Fuse'
        });
        window.previewObject = preview;
        canvas.add(preview);
        canvas.renderAll();
        updateZOrder();
      });
      return;
    } else {
      // สำหรับ type อื่นๆ ใช้ SVG จาก URL ถ้ามี
      let svgUrl = "";
      if (window.selectedDeviceType === 'ExternalGrid')
        svgUrl = "{% static 'svg/external/Externalgrid.svg' %}";
      // ตรวจสอบการโหลด SVG แบบ cached (ถ้ามี)
      if (window.loadedSVG[svgUrl]) {
        const preview = fabric.util.object.clone(window.loadedSVG[svgUrl]);
        preview.set({
          left: pointer.x,
          top: pointer.y,
          opacity: 0.5,
          selectable: false,
          evented: false,
          originX: 'center',
          originY: 'center'
        });
        window.previewObject = preview;
        canvas.add(preview);
        canvas.renderAll();
        updateZOrder();
        return;
      }
      fabric.loadSVGFromURL(svgUrl, function(objects, options) {
        if (!objects || objects.length === 0) {
          alert("ไม่สามารถโหลดไฟล์ SVG: " + svgUrl);
          console.error("SVG โหลดไม่สำเร็จ:", svgUrl);
          return;
        }
        objects.forEach(function(obj) {
          if (obj.type === 'text' && obj.textBaseline === 'alphabetical') {
            obj.set('textBaseline', 'alphabetic');
          }
        });
        let preview = new fabric.Group(objects, options);
        preview.scaleToWidth(75);
        preview.set({
          left: pointer.x,
          top: pointer.y,
          opacity: 0.5,
          selectable: false,
          evented: false,
          originX: 'center',
          originY: 'center'
        });
        window.previewObject = preview;
        canvas.add(preview);
        canvas.renderAll();
        updateZOrder();
      });
    }
  }

  // selectDevice: กำหนด selectedDeviceType และสร้าง preview เริ่มต้น
  window.selectDevice = function(type) {
    window.selectedDeviceType = type;
    console.log("Selected device type:", type);
    if (window.previewObject) {
      canvas.remove(window.previewObject);
      window.previewObject = null;
    }
    updatePreview({ x: 0, y: 0 });
    if (type === "Line") window.lineStartNode = null;
  };

  canvas.on('mouse:dblclick', function(e) {
    if (e.target && (e.target.type === 'group' || e.target.type === 'text' || e.target.type === 'line')) {
      let deviceType = e.target.deviceType ||
          (e.target.type === 'text' || e.target.type === 'line' ? 'Line' : 'Unknown');
      console.log("Double-click on deviceType:", deviceType);
      openTitleBox(deviceType);
    }
  });

  canvas.on('mouse:move', function(e) {
    const pointer = canvas.getPointer(e.e);
    if (window.selectedDeviceType) {
      updatePreview(pointer);
    } else if (canvas.isDragging) {
      var vpt = canvas.viewportTransform;
      vpt[4] += e.e.clientX - canvas.lastPosX;
      vpt[5] += e.e.clientY - canvas.lastPosY;
      canvas.requestRenderAll();
      canvas.lastPosX = e.e.clientX;
      canvas.lastPosY = e.e.clientY;
    }
    if (window.pendingManualConnectionDevice && window.pendingManualConnectionDevice.connectionNodes.length < 2) {
      const center = window.pendingManualConnectionDevice.getCenterPoint();
      if (!window.devicePendingPreviewLine) {
        window.devicePendingPreviewLine = new fabric.Line(
          [center.x, center.y, pointer.x, pointer.y],
          { stroke: 'red', strokeWidth: 4, selectable: false, evented: false, opacity: 0.5 }
        );
        canvas.add(window.devicePendingPreviewLine);
      } else {
        window.devicePendingPreviewLine.set({
          x1: center.x,
          y1: center.y,
          x2: pointer.x,
          y2: pointer.y
        });
      }
    } else if (window.devicePendingPreviewLine) {
      canvas.remove(window.devicePendingPreviewLine);
      window.devicePendingPreviewLine = null;
    }
    canvas.renderAll();
  });

  canvas.on('mouse:down', function(e) {
    const currentTime = new Date().getTime();
    const timeDiff = currentTime - (window.lastClickTime || 0);
    window.lastClickTime = currentTime;
    
    if (timeDiff < 300 && e.target &&
        (e.target.type === 'group' || e.target.type === 'text' || e.target.type === 'line')) {
      let deviceType = e.target.deviceType ||
          (e.target.type === 'text' || e.target.type === 'line' ? 'Line' : 'Unknown');
      console.log("Double-click detected on deviceType:", deviceType);
      openTitleBox(deviceType);
    }
    if (e.e.button === 0 && e.e.ctrlKey && e.target) {
      if (e.target.type === 'group') {
        let obj = e.target;
        obj.set('flipX', !obj.get('flipX'));
        obj.set('flipY', !obj.get('flipY'));
        obj.setCoords();
        canvas.renderAll();
        console.log("Device flipped: flipX =", obj.get('flipX'), "flipY =", obj.get('flipY'));
        return;
      }
    }
    if (e.e.button === 0 && e.e.ctrlKey && !e.target) {
      canvas.isDragging = true;
      canvas.lastPosX = e.e.clientX;
      canvas.lastPosY = e.e.clientY;
      canvas.renderAll();
      return;
    }
    if (e.e.button === 0 && window.selectedDeviceType && window.selectedDeviceType !== "Line" && !e.target) {
      const pointer = canvas.getPointer(e.e);
      addDevice(window.selectedDeviceType, pointer.x, pointer.y);
      if (window.selectedDeviceType !== 'Node') {
        if (window.previewObject) {
          canvas.remove(window.previewObject);
          window.previewObject = null;
        }
        window.selectedDeviceType = null;
      }
    }
    if (e.e.button === 0 && window.selectedDeviceType === "Line" && e.target && e.target.type === 'circle') {
      const node = e.target;
      if (!window.lineStartNode) {
        window.lineStartNode = node;
        let startCenter = node.getCenterPoint();
        if (window.manualLinePreview) {
          canvas.remove(window.manualLinePreview);
          window.manualLinePreview = null;
        }
        window.manualLinePreview = new fabric.Line(
          [startCenter.x, startCenter.y, startCenter.x, startCenter.y],
          { stroke: 'blue', strokeWidth: 4, selectable: false, evented: false, opacity: 0.5 }
        );
        canvas.add(window.manualLinePreview);
        canvas.renderAll();
        console.log("Line start node set.");
      } else if (window.lineStartNode && window.lineStartNode !== node) {
        let startCenter = window.lineStartNode.getCenterPoint();
        let endCenter = node.getCenterPoint();
        let snappedStart = snapPointToGrid(startCenter.x, startCenter.y);
        let snappedEnd = snapPointToGrid(endCenter.x, endCenter.y);
        let finalLine = new fabric.Line(
          [snappedStart.x, snappedStart.y, snappedEnd.x, snappedEnd.y],
          { stroke: 'black', strokeWidth: 4, selectable: true, evented: true,
            lockScalingX: true, lockScalingY: true, lockRotation: true }
        );
        finalLine.myStartNode = window.lineStartNode;
        finalLine.myEndNode = node;
        finalLine.on('modified', function() {
          let newStart = finalLine.myStartNode.getCenterPoint();
          let newEnd = finalLine.myEndNode.getCenterPoint();
          finalLine.set({ x1: newStart.x, y1: newStart.y, x2: newEnd.x, y2: newEnd.y });
          canvas.renderAll();
        });
        canvas.add(finalLine);
        updateZOrder();
        canvas.renderAll();
        console.log("Line manually connected between nodes.");
        window.lineStartNode = null;
        if (window.manualLinePreview) {
          canvas.remove(window.manualLinePreview);
          window.manualLinePreview = null;
        }
        window.selectedDeviceType = null;
        if (window.previewObject) {
          canvas.remove(window.previewObject);
          window.previewObject = null;
        }
      }
    }
    if (e.e.button === 1 && !window.selectedDeviceType && !e.target) {
      canvas.isDragging = true;
      canvas.lastPosX = e.e.clientX;
      canvas.lastPosY = e.e.clientY;
    }
  });

  canvas.on('mouse:up', function(e) {
    if (canvas.isDragging && e.e.button === 0) {
      canvas.isDragging = false;
      window.selectedDeviceType = null;
      window.lineStartNode = null;
      window.pendingManualConnectionDevice = null;
      if (window.previewObject) {
        canvas.remove(window.previewObject);
        window.previewObject = null;
      }
      if (window.manualLinePreview) {
        canvas.remove(window.manualLinePreview);
        window.manualLinePreview = null;
      }
      if (window.devicePendingPreviewLine) {
        canvas.remove(window.devicePendingPreviewLine);
        window.devicePendingPreviewLine = null;
      }
      canvas.discardActiveObject();
      canvas.getObjects().forEach(function(obj) {
        if (obj.type === 'line' && (obj.myStartNode || obj.myEndNode)) {
          let start = obj.myStartNode.getCenterPoint();
          let end = obj.myEndNode.getCenterPoint();
          obj.set({ x1: start.x, y1: start.y, x2: end.x, y2: end.y });
          obj.setCoords();
        }
      });
      canvas.getObjects().forEach(function(obj) {
        if (obj.type === 'group' || obj.type === 'circle') {
          const center = obj.getCenterPoint();
          const offset = gridSize / 2;
          const newX = offset + Math.round((center.x - offset) / gridSize) * gridSize;
          const newY = offset + Math.round((center.y - offset) / gridSize) * gridSize;
          obj.setPositionByOrigin(new fabric.Point(newX, newY), 'center', 'center');
          obj.setCoords();
        }
      });
      updateZOrder();
      canvas.renderAll();
    }
    if (canvas.isDragging && e.e.button === 1) {
      canvas.isDragging = false;
      window.selectedDeviceType = null;
      window.lineStartNode = null;
      window.pendingManualConnectionDevice = null;
      if (window.previewObject) {
        canvas.remove(window.previewObject);
        window.previewObject = null;
      }
      if (window.devicePendingPreviewLine) {
        canvas.remove(window.devicePendingPreviewLine);
        window.devicePendingPreviewLine = null;
      }
      if (window.manualLinePreview) {
        canvas.remove(window.manualLinePreview);
        window.manualLinePreview = null;
      }
      canvas.discardActiveObject();
      canvas.getObjects().forEach(function(obj) {
        if (obj.type === 'line' && (obj.myStartNode || obj.myEndNode)) {
          let start = obj.myStartNode.getCenterPoint();
          let end = obj.myEndNode.getCenterPoint();
          obj.set({ x1: start.x, y1: start.y, x2: end.x, y2: end.y });
          obj.setCoords();
        }
      });
      canvas.getObjects().forEach(function(obj) {
        if (obj.type === 'group' || obj.type === 'circle') {
          const center = obj.getCenterPoint();
          const offset = gridSize / 2;
          const newX = offset + Math.round((center.x - offset) / gridSize) * gridSize;
          const newY = offset + Math.round((center.y - offset) / gridSize) * gridSize;
          obj.setPositionByOrigin(new fabric.Point(newX, newY), 'center', 'center');
          obj.setCoords();
        }
      });
      updateZOrder();
      canvas.renderAll();
    }
  });

  canvas.upperCanvasEl.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    if (window.previewObject) {
      canvas.remove(window.previewObject);
      window.previewObject = null;
    }
    window.selectedDeviceType = null;
    window.lineStartNode = null;
    console.log("Preview cancelled.");
  });

  // updateConnectionLines: อัปเดตเส้นเชื่อม
  function updateConnectionLines(device, connectionNodes) {
    const deviceCenter = device.getCenterPoint();
    connectionNodes.forEach(function(node, index) {
      const nodeCenter = node.getCenterPoint();
      if (device.connectionLines[index]) {
        device.connectionLines[index].set({
          x1: deviceCenter.x,
          y1: deviceCenter.y,
          x2: nodeCenter.x,
          y2: nodeCenter.y,
        });
      }
    });
    updateZOrder();
  }

  // addNode: สร้าง Node พร้อม label
  window.nodeCounter = 1;
  window.addNode = function(x, y, options = {}) {
    const defaultOptions = {
      left: x,
      top: y,
      radius: 2,
      fill: 'Black',
      selectable: true,
      hasControls: false,
      originX: 'center',
      originY: 'center',
      lockScalingX: true,
      lockScalingY: true,
      nodeName: String(window.nodeCounter)
    };
    window.nodeCounter++;
    const nodeOptions = Object.assign({}, defaultOptions, options);
    var node = new fabric.Circle(nodeOptions);
    node.connectedDevices = [];
    node.connectionNodes = [];
    node.connectionLines = [];
    canvas.add(node);
    node.bringToFront();
    window.allNodes.push(node);
    attachManualConnectionListener(node);
    node.on('selected', function() {
      if (!node.label) {
        node.label = new fabric.Text(node.nodeName, {
          left: node.left,
          top: node.top - node.radius - 12,
          fontSize: 12,
          fill: 'black',
          selectable: false,
          evented: false,
          originX: 'center'
        });
        canvas.add(node.label);
        node.label.sendToBack();
      }
      console.log("Node selected:", node.nodeName);
    });
    node.on('deselected', function() {
      if (node.label) {
        canvas.remove(node.label);
        node.label = null;
      }
    });
    node.on('moving', function() {
      node.setCoords();
      if (node.label) {
        node.label.set({
          left: node.left,
          top: node.top - node.radius - 10
        });
      }
      canvas.getObjects().forEach(function(obj) {
        if (obj.type === 'line' && (obj.myStartNode === node || obj.myEndNode === node)) {
          let start = obj.myStartNode.getCenterPoint();
          let end = obj.myEndNode.getCenterPoint();
          obj.set({ x1: start.x, y1: start.y, x2: end.x, y2: end.y });
        }
      });
      node.connectedDevices.forEach(function(device) {
        const idx = device.connectionNodes.indexOf(node);
        if (idx !== -1 && device.connectionLines[idx]) {
          device.connectionLines[idx].set({
            x2: node.getCenterPoint().x,
            y2: node.getCenterPoint().y,
          });
        }
      });
      canvas.requestRenderAll();
    });
    attachManualConnectionListener(node);
    return node;
  };

  // updateGridBackground: ตั้งค่าแบ็คกราวด์ด้วย grid
  function updateGridBackground(canvas, gridSize) {
    var zoom = canvas.getZoom();
    var patternSize = gridSize;
    var baseDotRadius = 3;
    var dotRadius = baseDotRadius * zoom;
    var patternCanvas = document.createElement('canvas');
    patternCanvas.width = patternSize;
    patternCanvas.height = patternSize;
    var ctx = patternCanvas.getContext('2d');
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, patternSize, patternSize);
    ctx.beginPath();
    ctx.arc(patternSize / 2, patternSize / 2, dotRadius, 0, Math.PI * 2, false);
    ctx.fillStyle = '#ccc';
    ctx.fill();
    var patternDataUrl = patternCanvas.toDataURL('image/png');
    canvas.setBackgroundColor({ source: patternDataUrl, repeat: 'repeat' }, function() {
      canvas.renderAll();
    });
  }

  // resizeCanvas: ปรับขนาด Canvas ตามความกว้างของ content
  function resizeCanvas() {
    const contentWidth = document.getElementById('content').clientWidth;
    canvas.setWidth(contentWidth);
    canvas.setHeight(contentWidth * 9 / 16);
    canvas.renderAll();
    updateGridBackground(canvas, gridSize);
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  canvas.calcOffset();

  // checkForNewConnections: (สำหรับ Auto-connection, ไม่เกี่ยวกับ manual)
  function checkForNewConnections(device) {
    const deviceCenter = device.getCenterPoint();
    let autoConnected = false;
    window.allNodes.forEach(function(node) {
      const nodeCenter = node.getCenterPoint();
      const d = distance(deviceCenter, nodeCenter);
      if (d <= connectionThreshold && device.connectionNodes.length < 2) {
        if (!device.connectionNodes.includes(node)) {
          device.connectionNodes.push(node);
          node.connectedDevices.push(device);
          node.offsetFromDevice = {
            x: nodeCenter.x - deviceCenter.x,
            y: nodeCenter.y - deviceCenter.y
          };
          let line = new fabric.Line(
            [deviceCenter.x, deviceCenter.y, nodeCenter.x, nodeCenter.y],
            { stroke: 'black', strokeWidth: 4, selectable: false, evented: false }
          );
          line.myDevice = device;
          line.myNode = node;
          line.on('modified', function() {
            let newDeviceCenter = line.myDevice.getCenterPoint();
            let newNodeCenter = line.myNode.getCenterPoint();
            line.set({
              x1: newDeviceCenter.x,
              y1: newDeviceCenter.y,
              x2: newNodeCenter.x,
              y2: newNodeCenter.y
            });
            canvas.renderAll();
          });
          device.connectionLines.push(line);
          canvas.add(line);
          autoConnected = true;
        }
      }
    });
    if (!autoConnected) {
      window.pendingManualConnectionDevice = device;
      showManualPreviewLine(device);
    }
    updateZOrder();
    if (device.connectionNodes.length === 2) {
      updateDeviceRotation(device);
    }
  }

  // attachManualConnectionListener: ผูก event ให้กับ Node
  function attachManualConnectionListener(node) {
    node.on('mousedown', function(e) {
      if (window.pendingManualConnectionDevice) {
        if (!canvas.getObjects().includes(window.pendingManualConnectionDevice)) {
          window.pendingManualConnectionDevice = null;
          if (window.devicePendingPreviewLine) {
            canvas.remove(window.devicePendingPreviewLine);
            window.devicePendingPreviewLine = null;
          }
          return;
        }
      }
      var device = window.pendingManualConnectionDevice;
      if (!device) return;
      if (device.connectionNodes && device.connectionNodes.includes(node)) {
        return;
      }
      if (window.pendingManualConnectionDevice) {
        var device = window.pendingManualConnectionDevice;
        if (window.selectedDeviceType !== "Line") {
          if (device.connectionNodes.length >= 2) return;
          var deviceCenter = device.getCenterPoint();
          var nodeCenter = node.getCenterPoint();
          let snappedStart = snapPointToGrid(deviceCenter.x, deviceCenter.y);
          let snappedEnd = snapPointToGrid(nodeCenter.x, nodeCenter.y);
          var d = distance(deviceCenter, nodeCenter);
          var manualThreshold = 500;
          if (d <= manualThreshold) {
            device.connectionNodes.push(node);
            node.connectedDevices.push(device);
            var line = new fabric.Line(
              [snappedStart.x, snappedStart.y, snappedEnd.x, snappedEnd.y],
              { stroke: 'black', strokeWidth: 4, selectable: false, evented: false }
            );
            line.myDevice = device;
            line.myNode = node;
            canvas.add(line);
            line.on('modified', function() {
              let newDeviceCenter = line.myDevice.getCenterPoint();
              let newNodeCenter = line.myNode.getCenterPoint();
              line.set({
                x1: newDeviceCenter.x,
                y1: newDeviceCenter.y,
                x2: newNodeCenter.x,
                y2: newNodeCenter.y
              });
              canvas.renderAll();
            });
            device.connectionLines.push(line);
            updateZOrder();
            canvas.renderAll();
            window.pendingManualConnectionDevice = null;
            if (window.devicePendingPreviewLine) {
              canvas.remove(window.devicePendingPreviewLine);
              window.devicePendingPreviewLine = null;
            }
            if (device.connectionNodes.length === 2) {
              updateDeviceRotation(device);
            }
          }
        }
        if (window.selectedDeviceType === "Line") {
          if (!window.lineStartNode) {
            window.lineStartNode = node;
            let startCenter = node.getCenterPoint();
            if (window.manualLinePreview) {
              canvas.remove(window.manualLinePreview);
              window.manualLinePreview = null;
            }
            window.manualLinePreview = new fabric.Line(
              [startCenter.x, startCenter.y, startCenter.x, startCenter.y],
              { stroke: 'blue', strokeWidth: 4, selectable: false, evented: false, opacity: 0.5 }
            );
            canvas.add(window.manualLinePreview);
            canvas.renderAll();
          } else if (window.lineStartNode && window.lineStartNode !== node) {
            let startCenter = window.lineStartNode.getCenterPoint();
            let endCenter = node.getCenterPoint();
            let finalLine = new fabric.Line(
              [startCenter.x, startCenter.y, endCenter.x, endCenter.y],
              { stroke: 'black', strokeWidth: 4, selectable: true, evented: true,
                lockScalingX: true, lockScalingY: true, lockRotation: true }
            );
            finalLine.myStartNode = window.lineStartNode;
            finalLine.myEndNode = node;
            finalLine.deviceType = "Line";
            finalLine.on('modified', function() {
              let newStart = finalLine.myStartNode.getCenterPoint();
              let newEnd = finalLine.myEndNode.getCenterPoint();
              finalLine.set({ x1: newStart.x, y1: newStart.y, x2: newEnd.x, y2: newEnd.y });
              canvas.renderAll();
            });
            canvas.add(finalLine);
            updateZOrder();
            canvas.renderAll();
            window.lineStartNode = null;
            if (window.manualLinePreview) {
              canvas.remove(window.manualLinePreview);
              window.manualLinePreview = null;
            }
            window.selectedDeviceType = null;
            if (window.previewObject) {
              canvas.remove(window.previewObject);
              window.previewObject = null;
            }
          }
        }
      }
    });
    node.on('mouseover', function(e) {
      if (window.selectedDeviceType === "Line" && window.lineStartNode && window.lineStartNode !== node) {
        let startCenter = window.lineStartNode.getCenterPoint();
        let endCenter = node.getCenterPoint();
        if (window.manualLinePreview) {
          canvas.remove(window.manualLinePreview);
          window.manualLinePreview = null;
        }
        window.manualLinePreview = new fabric.Line(
          [startCenter.x, startCenter.y, endCenter.x, endCenter.y],
          { stroke: 'blue', strokeWidth: 4, selectable: false, evented: false, opacity: 0.5 }
        );
        canvas.add(window.manualLinePreview);
        updateZOrder();
        canvas.renderAll();
      }
    });
    node.on('mouseout', function(e) {
      if (window.manualLinePreview) {
        canvas.remove(window.manualLinePreview);
        window.manualLinePreview = null;
        canvas.renderAll();
      }
    });
  }

  // addDevice: เพิ่มอุปกรณ์ลงใน canvas (โค้ดเดิม, เพิ่ม updateZOrder() หลังเพิ่ม device)
  window.addDevice = function(type, left, top) {
    const snapped = snapPointToGrid(left, top);
    left = snapped.x;
    top = snapped.y;
    if (type === 'Node') {
      const node = window.addNode(left, top, { fill: 'Black', radius: 4 });
      node.bringToFront();
      return;
    }
    if (window.allNodes.length < 1) {
      alert("กรุณาสร้าง Node อย่างน้อย 1 จุดก่อนวางอุปกรณ์");
      return;
    }
    if (type === 'Line') {
      window.selectedDeviceType = "Line";
      window.lineStartNode = null;
      updatePreview({ x: left, y: top });
      return;
    }
    if (type === 'Recloser') {
      fabric.loadSVGFromString(inlineRecloserSVG, function(objects, options) {
        const deviceSVG = new fabric.Group(objects, options);
        deviceSVG.scaleToWidth(40);
        const bgRect = new fabric.Rect({
    width: deviceSVG.getScaledWidth(),
    height: deviceSVG.getScaledHeight(),
    fill: 'white'
  });
  
  // รวมพื้นหลังและ SVG เข้าด้วยกันให้อยู่ในกลุ่มเดียว
  const device = new fabric.Group([bgRect, deviceSVG], {
    left: deviceSVG.left,
    top: deviceSVG.top,
    originX: 'center',
    originY: 'center'
  });
        device.set({
          left: left,
          top: top,
          originX: 'center',
          originY: 'center',
          hasControls: true,
          selectable: true,
          lockScalingX: true,
          lockScalingY: true,
          hasBorders: false,
          deviceType: type
        });
        device.setControlsVisibility({ mtr: false });
        device.connectionNodes = [];
        device.connectionLines = [];
        canvas.add(device);
        canvas.setActiveObject(device);
        device.on('selected', function() {
          if (device.connectionNodes.length < 2) {
            window.pendingManualConnectionDevice = device;
            showManualPreviewLine(device);
          }
        });
        device.setCoords();
        canvas.renderAll();
        updateZOrder();
        if (!device.manualOnly) { checkForNewConnections(device); }
        updateConnectionLines(device, device.connectionNodes);
        device.on('modified', function() {
          checkForNewConnections(device);
          updateConnectionLines(device, device.connectionNodes);
        });
        device.on('removed', function() {
          removeDeviceConnections(device);
        });
        device.on('rotating', function(e) {
          let angle = device.get('angle');
          let snappedAngle = Math.round(angle / 90) * 90;
          device.set('angle', snappedAngle);
          device.setCoords();
          canvas.renderAll();
          console.log("Snapped rotation to:", snappedAngle);
        });
        window.connectedDevices.push(device);
        updateZOrder();
      });
      return;
    }
    if (type === 'Fuse') {
      fabric.loadSVGFromString(inlineFuseSVG, function(objects, options) {
        if (!objects || objects.length === 0) return;
        const deviceSVG = new fabric.Group(objects, options);
        deviceSVG.scaleToWidth(40);
        const bgRect = new fabric.Rect({
    width: deviceSVG.getScaledWidth(),
    height: deviceSVG.getScaledHeight(),
    fill: 'white'
  });
  
  // รวมพื้นหลังและ SVG เข้าด้วยกันให้อยู่ในกลุ่มเดียว
  const device = new fabric.Group([bgRect, deviceSVG], {
    left: deviceSVG.left,
    top: deviceSVG.top,
    originX: 'center',
    originY: 'center'
  });
        device.set({
          left: left,
          top: top,
          originX: 'center',
          originY: 'center',
          hasControls: true,
          selectable: true,
          lockScalingX: true,
          lockScalingY: true,
          hasBorders: false,
          deviceType: type
        });
        device.setControlsVisibility({ mtr: false });
        device.connectionNodes = [];
        device.connectionLines = [];
        canvas.add(device);
        canvas.setActiveObject(device);
        device.on('selected', function() {
          if (device.connectionNodes.length < 2) {
            window.pendingManualConnectionDevice = device;
            showManualPreviewLine(device);
          }
        });
        device.setCoords();
        canvas.renderAll();
        updateZOrder();
        if (!device.manualOnly) { checkForNewConnections(device); }
        updateConnectionLines(device, device.connectionNodes);
        device.on('modified', function() {
          checkForNewConnections(device);
          updateConnectionLines(device, device.connectionNodes);
        });
        device.on('removed', function() {
          removeDeviceConnections(device);
        });
        device.on('rotating', function(e) {
          let angle = device.get('angle');
          let snappedAngle = Math.round(angle / 90) * 90;
          device.set('angle', snappedAngle);
          device.setCoords();
          canvas.renderAll();
          console.log("Snapped rotation to:", snappedAngle);
        });
        window.connectedDevices.push(device);
        updateZOrder();
      });
      return;
    }
    if (type === 'ExternalGrid') {
      fabric.loadSVGFromString(inlineExternalGridSVG, function(objects, options) {
        if (!objects || objects.length === 0) return;
        const deviceSVG = new fabric.Group(objects, options);
        deviceSVG.scaleToWidth(40);
        const bgRect = new fabric.Rect({
    width: deviceSVG.getScaledWidth(),
    height: deviceSVG.getScaledHeight(),
    fill: 'white'
  });
  
  // รวมพื้นหลังและ SVG เข้าด้วยกันให้อยู่ในกลุ่มเดียว
  const device = new fabric.Group([bgRect, deviceSVG], {
    left: deviceSVG.left,
    top: deviceSVG.top,
    originX: 'center',
    originY: 'center'
  });
        device.set({
          left: left,
          top: top,
          originX: 'center',
          originY: 'center',
          hasControls: true,
          selectable: true,
          lockScalingX: true,
          lockScalingY: true,
          hasBorders: false,
          deviceType: type
        });
        device.setControlsVisibility({ mtr: false });
        device.connectionNodes = [];
        device.connectionLines = [];
        canvas.add(device);
        canvas.setActiveObject(device);
        device.on('selected', function() {
          if (device.connectionNodes.length < 2) {
            window.pendingManualConnectionDevice = device;
            showManualPreviewLine(device);
          }
        });
        device.setCoords();
        canvas.renderAll();
        updateZOrder();
        if (!device.manualOnly) { checkForNewConnections(device); }
        updateConnectionLines(device, device.connectionNodes);
        device.on('modified', function() {
          checkForNewConnections(device);
          updateConnectionLines(device, device.connectionNodes);
        });
        device.on('removed', function() {
          removeDeviceConnections(device);
        });
        device.on('rotating', function(e) {
          let angle = device.get('angle');
          let snappedAngle = Math.round(angle / 90) * 90;
          device.set('angle', snappedAngle);
          device.setCoords();
          canvas.renderAll();
          console.log("Snapped rotation to:", snappedAngle);
        });
        window.connectedDevices.push(device);
        updateZOrder();
      });
      return;
    }
  };

  canvas.on('mouse:wheel', function(opt) {
    if (!opt.e.ctrlKey) return;
    let delta = opt.e.deltaY;
    let zoom = canvas.getZoom();
    zoom *= Math.pow(0.999, delta);
    zoom = Math.max(0.01, Math.min(zoom, 20));
    canvas.setZoom(zoom);
    canvas.renderAll();
    updateGridBackground(canvas, gridSize);
    opt.e.preventDefault();
    opt.e.stopPropagation();
  });

  canvas.on('object:moving', function(e) {
    const obj = e.target;
    const center = obj.getCenterPoint();
    const offset = gridSize / 2;
    const newX = offset + Math.round((center.x - offset) / gridSize) * gridSize;
    const newY = offset + Math.round((center.y - offset) / gridSize) * gridSize;
    obj.setPositionByOrigin(new fabric.Point(newX, newY), 'center', 'center');
    if (obj.connectionNodes && obj.connectionNodes.length > 0) {
      const deviceCenter = obj.getCenterPoint();
      obj.connectionNodes.forEach(function(node, index) {
        const nodeCenter = node.getCenterPoint();
        if (obj.connectionLines[index]) {
          obj.connectionLines[index].set({
            x1: deviceCenter.x,
            y1: deviceCenter.y,
            x2: nodeCenter.x,
            y2: nodeCenter.y,
          });
        }
      });
    }
    canvas.getObjects().forEach(function(obj) {
      if (obj.type === 'line' && (obj.myStartNode || obj.myEndNode)) {
        let start = obj.myStartNode.getCenterPoint();
        let end = obj.myEndNode.getCenterPoint();
        obj.set({ x1: start.x - 2, y1: start.y - 2, x2: end.x - 2, y2: end.y - 2 });
      }
    });
    canvas.renderAll();
  });

  document.addEventListener('keydown', function(e) {
    if (e.key === 'Delete' || e.key === 'Backspace') {
      const activeObject = canvas.getActiveObject();
      if (activeObject) {
        canvas.remove(activeObject);
        canvas.discardActiveObject();
        canvas.requestRenderAll();
      }
    }
  });

  window.clearCanvas = function() {
    canvas.getObjects().forEach(function(obj) {
      if (obj.evented !== false) canvas.remove(obj);
    });
    canvas.requestRenderAll();
    window.selectedNodes = [];
    window.allNodes = [];
    window.connectedDevices = [];
    if (window.previewObject) window.previewObject = null;
  };

  function updateGridBackground(canvas, gridSize) {
    var zoom = canvas.getZoom();
    var patternSize = gridSize;
    var baseDotRadius = 3;
    var dotRadius = baseDotRadius * zoom;
    var patternCanvas = document.createElement('canvas');
    patternCanvas.width = patternSize;
    patternCanvas.height = patternSize;
    var ctx = patternCanvas.getContext('2d');
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, patternSize, patternSize);
    ctx.beginPath();
    ctx.arc(patternSize / 2, patternSize / 2, dotRadius, 0, Math.PI * 2, false);
    ctx.fillStyle = '#ccc';
    ctx.fill();
    var patternDataUrl = patternCanvas.toDataURL('image/png');
    canvas.setBackgroundColor({ source: patternDataUrl, repeat: 'repeat' }, function() {
      canvas.renderAll();
    });
  }

  function resizeCanvas() {
    const contentWidth = document.getElementById('content').clientWidth;
    canvas.setWidth(contentWidth);
    canvas.setHeight(contentWidth * 9 / 16);
    canvas.renderAll();
    updateGridBackground(canvas, gridSize);
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  canvas.calcOffset();
});
</script>
{% endblock %}

